<?php

namespace Controllers\Abstract;

use Factory\ManagerFactory;
use Twig\Environment;
use model\Trait\TraitLaundryRoom;

abstract class AbstractController
{
    use TraitLaundryRoom;

    protected Environment $twig;
    protected ManagerFactory $managerFactory;
    protected string $csrfToken;

    public function __construct(Environment $twig, ManagerFactory $managerFactory)
    {
        $this->twig = $twig;
        $this->managerFactory = $managerFactory;
        $this->csrfToken = $this->createNewCsrfToken();
    }

    protected function getManager(string $class): object
    {
        return $this->managerFactory->get($class);
    }

    protected function parsePostData(array $postData): array
        /*
         * Receives an array containing all $_POST data sent by the form
         * Each entry is made up of key:value
         * The key shows what type of input was expected (int, string, etc)
         * These are then separated and returned as, for example :
         * "user_email" = ["type" => "email","value" => "lee@leerlandais.com"]
         */
    {
        $result = [];
        foreach ($postData as $key => $value) {
            if ($key === 'csrf:csrf_token' || $key === 'csrf_token') {
                continue;
            }
            if (str_contains($key, ':')) {
                list($type, $name) = explode(':', $key, 2);
            } else {
                $type = 'str';
                $name = $key;
            }
            if ($type !== "unset") {
                $result[$name] = ["type" => $type, "value" => $value];
            }
        }
        return $result;
    }

    protected function testAndClean(array $cleanThis): string|int|null
    {
        /*
         * Receives an array of data, normally generated by the parsePostData function
         * Switches through the 'type' of data received (email, string, int, etc)
         * Tests if data conforms to expected type (int or string)
         * Performs necessary sanitisation for data using my usual TraitLaundryRoom
         * Returns the sanitised data
         */
        if (empty($cleanThis)) return null;
        switch ($cleanThis["type"]) {
            case "int":
                return $this->intClean($cleanThis["value"]);
            case "str":
            case "phone":
                if ($this->findTheNeedles($cleanThis["value"])) {
                    $_SESSION["systemMessage"] = "Possible Injection Detecté";
                    header("Location: ./");
                    exit();
                }
                return $this->standardClean($cleanThis["value"]);
            case "json":
                if ($this->findTheNeedles($cleanThis["value"])) {
                    $_SESSION["systemMessage"] = "Possible Injection Detecté";
                    header("Location: ./");
                    exit();
                }
                return $this->simpleTrim($cleanThis["value"]);
            case "email":
                if ($this->findTheNeedles($cleanThis["value"])) {
                    $_SESSION["systemMessage"] = "Possible Injection Detecté";
                    header("Location: ./");
                    exit();
                }
                return $this->emailClean($cleanThis["value"]);
            case "pass":
                return $this->simpleTrim($cleanThis["value"]);
            case "date":
                return $this->dateClean($cleanThis["value"]);
        }

        return $cleanThis["value"];
    }

    protected function checkPermissions(string $level, string $role): void
    {
        if (!$this->verifyUserLevel($level, $role)) {
            $_SESSION["systemMessage"] = "Vous n'êtes pas autorisé à accéder à cette page.";
            header("Location: ./");
            exit();
        }
    }

    /**
     * Verifies whether the user's access level matches the required level.
     * Checks if user level JSON contains the necessary level
     *
     * @param string $level The required access level to verify.
     * @param string $userLevel The user's access levels (JSON).
     *
     * @return bool Returns true if user level is accepted or false if not
     */
    private function verifyUserLevel(string $level, string $userLevel): bool
    {
        if (!$userLevel) return false;
        if (!in_array($level, json_decode($userLevel))) return false;
        return true;
    }

    protected function verifyCsrfToken(?string $token): void
    {
        /*
         * Used on all forms.
         * Compares input csrfToken to session
         * If token is incorrect, user is returned to menu
         * If token is correct, it is destroyed and replaced
         */
        if (!isset($token) || $token != $_SESSION['csrf_token']) {
            $_SESSION = [];
            $_SESSION["systemMessage"] = "CSRF Token incorrect";
            header("Location: ?route=home");
            die();
        }
        unset($_SESSION['csrf_token']);
        $this->createNewCsrfToken();
    }

    protected function preparePostData(array $postData): array
    {
        /*
         * Centralises the regularly used parsePostData and testAndClean combination
         * Makes them available for all Controllers : DRY is the way
         */
        $parsedData = $this->parsePostData($_POST);
        foreach ($parsedData as &$data) {
            $data = $this->testAndClean($data);
        }
        return $parsedData;
    }

    /**
     * @throws RandomException
     */
    private function createNewCsrfToken(): string
    {
        if (!isset($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        return $_SESSION['csrf_token'];
    }
}
